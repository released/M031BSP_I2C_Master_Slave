; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\i2c_slave.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\i2c_slave.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M031\Include -I..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 -DBUILD_SLAVE_I2C --omf_browse=.\obj\i2c_slave.crf ..\i2c_slave.c]
                          THUMB

                          AREA ||i.I2C0_IRQHandler||, CODE, READONLY, ALIGN=2

                  I2C0_IRQHandler PROC
;;;144    
;;;145    void I2Cx_Slave_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;146    {
;;;147        uint32_t u32Status;
;;;148    
;;;149        u32Status = I2C_GET_STATUS(SLAVE_I2C);
000002  4908              LDR      r1,|L1.36|
000004  68c8              LDR      r0,[r1,#0xc]
;;;150    
;;;151        if (I2C_GET_TIMEOUT_FLAG(SLAVE_I2C))
000006  694a              LDR      r2,[r1,#0x14]
000008  43d2              MVNS     r2,r2
00000a  07d2              LSLS     r2,r2,#31
00000c  d006              BEQ      |L1.28|
;;;152        {
;;;153    //		printf("Clear I2C Timeout Flag\r\n");
;;;154    	
;;;155            /* Clear I2C Timeout Flag */
;;;156            I2C_ClearTimeoutFlag(SLAVE_I2C); 
;;;157        }    
;;;158        else
;;;159        {
;;;160            if (I2Cx_Slave_HandlerFn != NULL)
00000e  4906              LDR      r1,|L1.40|
000010  68ca              LDR      r2,[r1,#0xc]  ; I2Cx_Slave_HandlerFn
000012  2a00              CMP      r2,#0
000014  d001              BEQ      |L1.26|
;;;161                I2Cx_Slave_HandlerFn(u32Status);
000016  68c9              LDR      r1,[r1,#0xc]  ; I2Cx_Slave_HandlerFn
000018  4788              BLX      r1
                  |L1.26|
;;;162        }
;;;163    }
00001a  bd10              POP      {r4,pc}
                  |L1.28|
00001c  4608              MOV      r0,r1                 ;156
00001e  f7fffffe          BL       I2C_ClearTimeoutFlag
000022  bd10              POP      {r4,pc}
;;;164    
                          ENDP

                  |L1.36|
                          DCD      0x40080000
                  |L1.40|
                          DCD      ||.data||

                          AREA ||i.I2Cx_SlaveTRx||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  I2Cx_SlaveTRx PROC
;;;225    
;;;226    void I2Cx_SlaveTRx(uint32_t u32Status)
000000  b5fe              PUSH     {r1-r7,lr}
;;;227    {
000002  4604              MOV      r4,r0
;;;228    	uint8_t u8RxData = 0;
000004  2300              MOVS     r3,#0
000006  4668              MOV      r0,sp
000008  7003              STRB     r3,[r0,#0]
;;;229    	uint8_t u8TxData = 0;
00000a  7103              STRB     r3,[r0,#4]
;;;230    	uint8_t u8TempData = 0;	
;;;231    	uint16_t u16Rxlen = 0;
;;;232    
;;;233    	
;;;234        if(u32Status == SLAVE_RECEIVE_ADDRESS_ACK) //0x60                    	/* Own SLA+W has been receive; ACK has been return */
;;;235        {
;;;236            g_u8DataLen_s = 0;
;;;237    
;;;238    		I2Cx_Slave_StateMachine(u32Status , &u8TempData , &u8TempData);
;;;239    		
;;;240            I2C_SET_CONTROL_REG(SLAVE_I2C, I2C_CTL_SI | I2C_CTL_AA);
00000c  263c              MOVS     r6,#0x3c
00000e  4939              LDR      r1,|L2.244|
000010  4d39              LDR      r5,|L2.248|
000012  7203              STRB     r3,[r0,#8]            ;230
000014  2c60              CMP      r4,#0x60              ;234
000016  d065              BEQ      |L2.228|
000018  4608              MOV      r0,r1                 ;236
;;;241    
;;;242    		__I2Cx_Slave_Log__(u32Status);		
;;;243        }
;;;244        else if(u32Status == SLAVE_RECEIVE_DATA_ACK) //0x80                 		/* Previously address with own SLA address
;;;245    																			/* Data has been received; ACK has been returned*/
;;;246        {
;;;247            u8RxData = (unsigned char) I2C_GET_DATA(SLAVE_I2C);
;;;248    		
;;;249    //		__I2Cx_Slave_LogBuffer__(u32Status , g_u8RxData);		
;;;250    
;;;251    	    g_u8DataLen_s++;
;;;252    
;;;253    	    if(g_u8DataLen_s == 1)
;;;254    	    {
;;;255    			/*
;;;256    				Blind spot : register address can not larger than g_u8SlvData array size , 
;;;257    				due to resister address will be save as array start index to store data
;;;258    			
;;;259    			*/
;;;260    	        slave_buff_addr = u8RxData;	//register
;;;261    			
;;;262    			__I2Cx_Slave_LogBuffer__(g_u8DataLen_s , u8RxData);				
;;;263    	    }
;;;264    	    else
;;;265    	    {
;;;266    			u16Rxlen = slave_buff_addr+(g_u8DataLen_s-2);		//data buffer start	
;;;267    	        g_u8SlvData[u16Rxlen] = u8RxData;
00001a  4f38              LDR      r7,|L2.252|
00001c  6880              LDR      r0,[r0,#8]            ;236
00001e  2c80              CMP      r4,#0x80              ;244
000020  d013              BEQ      |L2.74|
000022  460a              MOV      r2,r1                 ;236
000024  6892              LDR      r2,[r2,#8]            ;236
000026  1c52              ADDS     r2,r2,#1              ;236
;;;268    			u8RxData = g_u8SlvData[u16Rxlen];
;;;269    			
;;;270    			__I2Cx_Slave_LogBuffer__(u16Rxlen , u8RxData);			
;;;271    	    }
;;;272    	
;;;273    		I2Cx_Slave_StateMachine(u32Status , &u8RxData , &u8TempData);
;;;274    				
;;;275            I2C_SET_CONTROL_REG(SLAVE_I2C, I2C_CTL_SI | I2C_CTL_AA);
;;;276    		
;;;277    		__I2Cx_Slave_Log__(u32Status);
;;;278        }
;;;279        else if(u32Status == SLAVE_TRANSMIT_ADDRESS_ACK) //0xA8               	/* Own SLA+R has been receive; ACK has been return */
000028  2ca8              CMP      r4,#0xa8
00002a  d030              BEQ      |L2.142|
;;;280        {
;;;281    		u8RxData = g_u8SlvData[slave_buff_addr++];
;;;282    
;;;283    		I2Cx_Slave_StateMachine(u32Status , &u8TempData, &u8TxData);	//u8RxData no process
;;;284    			
;;;285         	I2C_SET_DATA(SLAVE_I2C, u8TxData);	//I2C_SET_DATA(SLAVE_I2C, u8RxData);
;;;286            I2C_SET_CONTROL_REG(SLAVE_I2C, I2C_CTL_SI | I2C_CTL_AA);
;;;287    
;;;288    		__I2Cx_Slave_LogBuffer__(u32Status , u8TxData);
;;;289    		__I2Cx_Slave_Log__(u32Status);
;;;290        }
;;;291    	else if(u32Status == SLAVE_TRANSMIT_DATA_ACK) //0xB8                 	/* Data byte in I2CDAT has been transmitted
00002c  2cb8              CMP      r4,#0xb8
00002e  d040              BEQ      |L2.178|
;;;292    																			/* ACK has been received */
;;;293        {
;;;294    		u8RxData = g_u8SlvData[slave_buff_addr++];
;;;295    
;;;296    		I2Cx_Slave_StateMachine(u32Status , &u8TempData, &u8TxData);	//u8RxData no process	
;;;297    
;;;298    		I2C_SET_DATA(SLAVE_I2C, u8TxData);	//I2C_SET_DATA(SLAVE_I2C, u8RxData);
;;;299    		I2C_SET_CONTROL_REG(SLAVE_I2C, I2C_CTL_SI | I2C_CTL_AA);
;;;300    		
;;;301    		__I2Cx_Slave_LogBuffer__(u32Status, u8TxData);		
;;;302    		__I2Cx_Slave_Log__(u32Status);
;;;303        }
;;;304        else if(u32Status == SLAVE_TRANSMIT_DATA_NACK) //0xC0                 	/* Data byte or last data in I2CDAT has been transmitted
000030  2cc0              CMP      r4,#0xc0
000032  d052              BEQ      |L2.218|
;;;305    																			/* Not ACK has been received */
;;;306        {
;;;307    		I2Cx_Slave_StateMachine(u32Status , &u8TempData , &u8TempData);
;;;308    	
;;;309            I2C_SET_CONTROL_REG(SLAVE_I2C, I2C_CTL_SI | I2C_CTL_AA);
;;;310    		
;;;311    		__I2Cx_Slave_Log__(u32Status);
;;;312        }
;;;313        else if(u32Status == SLAVE_RECEIVE_DATA_NACK) //0x88                 		/* Previously addressed with own SLA address; NOT ACK has
000034  2c88              CMP      r4,#0x88
000036  d053              BEQ      |L2.224|
;;;314    																			/* been returned */
;;;315        {
;;;316            g_u8DataLen_s = 0;
;;;317            I2C_SET_CONTROL_REG(SLAVE_I2C, I2C_CTL_SI | I2C_CTL_AA);
;;;318    		
;;;319    		__I2Cx_Slave_Log__(u32Status);
;;;320        }
;;;321        else if(u32Status == SLAVE_TRANSMIT_REPEAT_START_OR_STOP) //0xA0    		/* A STOP or repeated START has been received while still
000038  2ca0              CMP      r4,#0xa0
00003a  d053              BEQ      |L2.228|
;;;322    																			/* addressed as Slave/Receiver*/
;;;323        {
;;;324            g_u8DataLen_s = 0;
;;;325    		I2Cx_Slave_StateMachine(u32Status , &u8TempData, &u8TempData);
;;;326    		
;;;327            I2C_SET_CONTROL_REG(SLAVE_I2C, I2C_CTL_SI | I2C_CTL_AA);
;;;328    
;;;329    		__I2Cx_Slave_Log__(u32Status);
;;;330        }
;;;331        else if(u32Status == BUS_ERROR) //0x00
00003c  2c00              CMP      r4,#0
00003e  d053              BEQ      |L2.232|
;;;332        {
;;;333    		I2C_SET_CONTROL_REG(SLAVE_I2C, I2C_CTL_STO_SI_AA);
;;;334    		I2C_SET_CONTROL_REG(SLAVE_I2C, I2C_CTL_SI_AA);
;;;335    		
;;;336    		__I2Cx_Slave_Log__(u32Status);		
;;;337        }																	
;;;338        else
;;;339        {
;;;340    		#if defined (DEBUG_LOG_SLAVE_LV2)
;;;341            /* TO DO */
;;;342            printf("I2Cx_SlaveTRx Status 0x%x is NOT processed\n", u32Status);
000040  4621              MOV      r1,r4
000042  a02f              ADR      r0,|L2.256|
000044  f7fffffe          BL       __2printf
;;;343    		#endif
;;;344        }
;;;345    }
000048  bdfe              POP      {r1-r7,pc}
                  |L2.74|
00004a  68aa              LDR      r2,[r5,#8]            ;247
00004c  b2d3              UXTB     r3,r2                 ;247
00004e  466a              MOV      r2,sp                 ;247
000050  7013              STRB     r3,[r2,#0]            ;247
000052  780a              LDRB     r2,[r1,#0]            ;251  ; g_u8DataLen_s
000054  1c52              ADDS     r2,r2,#1              ;251
000056  b2d2              UXTB     r2,r2                 ;251
000058  700a              STRB     r2,[r1,#0]            ;251
00005a  2a01              CMP      r2,#1                 ;253
00005c  d013              BEQ      |L2.134|
00005e  1880              ADDS     r0,r0,r2              ;266
000060  1e80              SUBS     r0,r0,#2              ;266
000062  b280              UXTH     r0,r0                 ;266
000064  543b              STRB     r3,[r7,r0]            ;267
000066  4669              MOV      r1,sp                 ;268
000068  700b              STRB     r3,[r1,#0]            ;268
00006a  b2c0              UXTB     r0,r0                 ;270
00006c  4619              MOV      r1,r3                 ;270
                  |L2.110|
00006e  f7fffffe          BL       __I2Cx_Slave_LogBuffer__
000072  aa02              ADD      r2,sp,#8              ;273
000074  4669              MOV      r1,sp                 ;273
                  |L2.118|
000076  4620              MOV      r0,r4                 ;238
000078  f7fffffe          BL       I2Cx_Slave_StateMachine
                  |L2.124|
00007c  6828              LDR      r0,[r5,#0]            ;240
00007e  43b0              BICS     r0,r0,r6              ;240
000080  300c              ADDS     r0,r0,#0xc            ;240
000082  6028              STR      r0,[r5,#0]            ;240
000084  bdfe              POP      {r1-r7,pc}
                  |L2.134|
000086  608b              STR      r3,[r1,#8]            ;260  ; slave_buff_addr
000088  4619              MOV      r1,r3                 ;260
00008a  4610              MOV      r0,r2                 ;260
00008c  e7ef              B        |L2.110|
                  |L2.142|
00008e  5c38              LDRB     r0,[r7,r0]            ;281
000090  466b              MOV      r3,sp                 ;281
000092  7018              STRB     r0,[r3,#0]            ;281
000094  608a              STR      r2,[r1,#8]            ;283  ; slave_buff_addr
000096  aa01              ADD      r2,sp,#4              ;283
000098  a902              ADD      r1,sp,#8              ;283
00009a  4620              MOV      r0,r4                 ;283
00009c  f7fffffe          BL       I2Cx_Slave_StateMachine
0000a0  466b              MOV      r3,sp                 ;285
0000a2  7919              LDRB     r1,[r3,#4]            ;285
0000a4  60a9              STR      r1,[r5,#8]            ;285
0000a6  6828              LDR      r0,[r5,#0]            ;286
0000a8  43b0              BICS     r0,r0,r6              ;286
0000aa  300c              ADDS     r0,r0,#0xc            ;286
0000ac  6028              STR      r0,[r5,#0]            ;286
0000ae  20a8              MOVS     r0,#0xa8              ;288
0000b0  e010              B        |L2.212|
                  |L2.178|
0000b2  5c38              LDRB     r0,[r7,r0]            ;294
0000b4  466b              MOV      r3,sp                 ;294
0000b6  7018              STRB     r0,[r3,#0]            ;294
0000b8  608a              STR      r2,[r1,#8]            ;296  ; slave_buff_addr
0000ba  aa01              ADD      r2,sp,#4              ;296
0000bc  a902              ADD      r1,sp,#8              ;296
0000be  4620              MOV      r0,r4                 ;296
0000c0  f7fffffe          BL       I2Cx_Slave_StateMachine
0000c4  466b              MOV      r3,sp                 ;298
0000c6  7919              LDRB     r1,[r3,#4]            ;298
0000c8  60a9              STR      r1,[r5,#8]            ;298
0000ca  6828              LDR      r0,[r5,#0]            ;299
0000cc  43b0              BICS     r0,r0,r6              ;299
0000ce  300c              ADDS     r0,r0,#0xc            ;299
0000d0  6028              STR      r0,[r5,#0]            ;299
0000d2  20b8              MOVS     r0,#0xb8              ;301
                  |L2.212|
0000d4  f7fffffe          BL       __I2Cx_Slave_LogBuffer__
0000d8  bdfe              POP      {r1-r7,pc}
                  |L2.218|
0000da  aa02              ADD      r2,sp,#8              ;307
0000dc  4611              MOV      r1,r2                 ;307
0000de  e7ca              B        |L2.118|
                  |L2.224|
0000e0  700b              STRB     r3,[r1,#0]            ;316
0000e2  e7cb              B        |L2.124|
                  |L2.228|
0000e4  700b              STRB     r3,[r1,#0]            ;324
0000e6  e7f8              B        |L2.218|
                  |L2.232|
0000e8  6828              LDR      r0,[r5,#0]            ;333
0000ea  43b0              BICS     r0,r0,r6              ;333
0000ec  301c              ADDS     r0,r0,#0x1c           ;333
0000ee  6028              STR      r0,[r5,#0]            ;333
0000f0  e7c4              B        |L2.124|
;;;346    
                          ENDP

0000f2  0000              DCW      0x0000
                  |L2.244|
                          DCD      ||.data||
                  |L2.248|
                          DCD      0x40080000
                  |L2.252|
                          DCD      ||.bss||
                  |L2.256|
000100  49324378          DCB      "I2Cx_SlaveTRx Status 0x%x is NOT processed\n",0
000104  5f536c61
000108  76655452
00010c  78205374
000110  61747573
000114  20307825
000118  78206973
00011c  204e4f54
000120  2070726f
000124  63657373
000128  65640a00

                          AREA ||i.I2Cx_Slave_Init||, CODE, READONLY, ALIGN=2

                  I2Cx_Slave_Init PROC
;;;346    
;;;347    void I2Cx_Slave_Init(void)
000000  b510              PUSH     {r4,lr}
;;;348    {    
;;;349        uint32_t i;
;;;350    
;;;351        /* Open I2C module and set bus clock */
;;;352        I2C_Open(SLAVE_I2C, 100000);
000002  4c23              LDR      r4,|L3.144|
000004  4921              LDR      r1,|L3.140|
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       I2C_Open
;;;353        
;;;354         /* Set I2C 4 Slave Addresses */            
;;;355        I2C_SetSlaveAddr(SLAVE_I2C, 0, 0x15, 0);   /* Slave Address : 0x15 */
00000c  2300              MOVS     r3,#0
00000e  2215              MOVS     r2,#0x15
000010  4619              MOV      r1,r3
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       I2C_SetSlaveAddr
;;;356        I2C_SetSlaveAddr(SLAVE_I2C, 1, 0x35, 0);   /* Slave Address : 0x35 */
000018  2300              MOVS     r3,#0
00001a  2235              MOVS     r2,#0x35
00001c  2101              MOVS     r1,#1
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       I2C_SetSlaveAddr
;;;357        I2C_SetSlaveAddr(SLAVE_I2C, 2, 0x55, 0);   /* Slave Address : 0x55 */
000024  2300              MOVS     r3,#0
000026  2255              MOVS     r2,#0x55
000028  2102              MOVS     r1,#2
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       I2C_SetSlaveAddr
;;;358        I2C_SetSlaveAddr(SLAVE_I2C, 3, 0x75, 0);   /* Slave Address : 0x75 */
000030  2300              MOVS     r3,#0
000032  2275              MOVS     r2,#0x75
000034  2103              MOVS     r1,#3
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       I2C_SetSlaveAddr
;;;359    
;;;360        I2C_SetSlaveAddrMask(SLAVE_I2C, 0, 0x01);
00003c  2201              MOVS     r2,#1
00003e  2100              MOVS     r1,#0
000040  4620              MOV      r0,r4
000042  f7fffffe          BL       I2C_SetSlaveAddrMask
;;;361        I2C_SetSlaveAddrMask(SLAVE_I2C, 1, 0x04);
000046  2204              MOVS     r2,#4
000048  2101              MOVS     r1,#1
00004a  4620              MOV      r0,r4
00004c  f7fffffe          BL       I2C_SetSlaveAddrMask
;;;362        I2C_SetSlaveAddrMask(SLAVE_I2C, 2, 0x01);
000050  2201              MOVS     r2,#1
000052  2102              MOVS     r1,#2
000054  4620              MOV      r0,r4
000056  f7fffffe          BL       I2C_SetSlaveAddrMask
;;;363        I2C_SetSlaveAddrMask(SLAVE_I2C, 3, 0x04);
00005a  2204              MOVS     r2,#4
00005c  2103              MOVS     r1,#3
00005e  4620              MOV      r0,r4
000060  f7fffffe          BL       I2C_SetSlaveAddrMask
;;;364    
;;;365        /* Enable I2C interrupt */
;;;366        I2C_EnableInt(SLAVE_I2C);
000064  4620              MOV      r0,r4
000066  f7fffffe          BL       I2C_EnableInt
00006a  2001              MOVS     r0,#1
00006c  4909              LDR      r1,|L3.148|
00006e  0480              LSLS     r0,r0,#18
000070  6008              STR      r0,[r1,#0]
;;;367        NVIC_EnableIRQ(SLAVE_I2C_IRQn);
;;;368    
;;;369    	/* I2C enter no address SLV mode */
;;;370        I2C_SET_CONTROL_REG(SLAVE_I2C, I2C_CTL_SI | I2C_CTL_AA);	
000072  6821              LDR      r1,[r4,#0]
000074  203c              MOVS     r0,#0x3c
000076  4381              BICS     r1,r1,r0
000078  310c              ADDS     r1,r1,#0xc
00007a  6021              STR      r1,[r4,#0]
;;;371    
;;;372    	for(i = 0; i < 0x100; i++)
00007c  2000              MOVS     r0,#0
;;;373    	{
;;;374    		g_u8SlvData[i] = 0;
00007e  4a06              LDR      r2,|L3.152|
000080  4601              MOV      r1,r0                 ;372
                  |L3.130|
000082  5411              STRB     r1,[r2,r0]
000084  1c40              ADDS     r0,r0,#1
000086  28ff              CMP      r0,#0xff              ;372
000088  d9fb              BLS      |L3.130|
;;;375    	}
;;;376    	
;;;377    }
00008a  bd10              POP      {r4,pc}
;;;378    
                          ENDP

                  |L3.140|
                          DCD      0x000186a0
                  |L3.144|
                          DCD      0x40080000
                  |L3.148|
                          DCD      0xe000e100
                  |L3.152|
                          DCD      ||.bss||

                          AREA ||i.I2Cx_Slave_StateMachine||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  I2Cx_Slave_StateMachine PROC
;;;52     
;;;53     void I2Cx_Slave_StateMachine(uint32_t res , uint8_t* InData, uint8_t* OutData)
000000  b5f8              PUSH     {r3-r7,lr}
;;;54     {
;;;55     	uint8_t i = 0;	
000002  2300              MOVS     r3,#0
;;;56     	static uint8_t u8Temp = 0;
;;;57     	static uint8_t cnt = _state_DEFAULT_;
;;;58     	
;;;59     	if (res == SLAVE_RECEIVE_ADDRESS_ACK)
;;;60     	{
;;;61     		cnt = _state_RECEIVE_ADDRESS_;
000004  4c2f              LDR      r4,|L4.196|
000006  461d              MOV      r5,r3                 ;55
000008  2860              CMP      r0,#0x60              ;59
00000a  d104              BNE      |L4.22|
00000c  2601              MOVS     r6,#1
00000e  7166              STRB     r6,[r4,#5]
;;;62     		slave_register_addr = 0;
000010  70e5              STRB     r5,[r4,#3]
;;;63     		g_u8FromMasterLen = 0;
000012  70a5              STRB     r5,[r4,#2]
;;;64     		g_u8ToMasterLen = 0;		
000014  7065              STRB     r5,[r4,#1]
                  |L4.22|
;;;65     	}
;;;66     
;;;67     	switch(cnt)
000016  7967              LDRB     r7,[r4,#5]  ; cnt
000018  2f01              CMP      r7,#1
00001a  d00f              BEQ      |L4.60|
;;;68     	{
;;;69     		case _state_RECEIVE_ADDRESS_:
;;;70     			if (res == SLAVE_RECEIVE_DATA_ACK)	
;;;71     			{
;;;72     				// first 0x80 ack is register address
;;;73     				if(g_u8DataLen_s == 1)
;;;74     				{
;;;75     					slave_register_addr = slave_buff_addr;
;;;76     					printf("slave_register_addr = 0x%2X\r\n" , slave_register_addr);
;;;77     				}
;;;78     				cnt = _state_CHECK_RX_OR_TX_;
;;;79     			}
;;;80     			break;
;;;81     
;;;82     		case _state_CHECK_RX_OR_TX_:
;;;83     			if (res == SLAVE_RECEIVE_DATA_ACK)	
;;;84     			{
;;;85     				// RX : contiune with multi 0x80 , end with 0xA0
;;;86     				// example : 0x60 > 0x80 (address) > 0x80 (data00)> 0x80 (data01) > ...> 0xA0
;;;87     				g_u8FromMasterData[g_u8FromMasterLen++] =  *InData;
00001c  4e2a              LDR      r6,|L4.200|
00001e  2f02              CMP      r7,#2                 ;67
000020  d018              BEQ      |L4.84|
000022  2f03              CMP      r7,#3                 ;67
000024  d024              BEQ      |L4.112|
000026  2f04              CMP      r7,#4                 ;67
000028  d107              BNE      |L4.58|
;;;88     				cnt = _state_RECEIVE_RX_;
;;;89     			}
;;;90     			else if (res == SLAVE_TRANSMIT_REPEAT_START_OR_STOP)	
;;;91     			{
;;;92     				// TX : following with 0xA0 , and 0xA8 (data01) , continue with 0xB8 (Data02)  , end with 0xC0
;;;93     				// example : 0x60 > 0x80 (address) > 0xA8 (data00) > 0xB8  (data01)> 0xB8  (data02) > ... > 0xC0
;;;94     				cnt = _state_TRANSMIT_TX_;
;;;95     			}
;;;96     			break;
;;;97     
;;;98     		case _state_RECEIVE_RX_:
;;;99     			if (res == SLAVE_TRANSMIT_REPEAT_START_OR_STOP)	
;;;100    			{
;;;101    				// end of RX
;;;102    
;;;103    				printf("g_u8FromMasterLen = %d\r\n" , g_u8FromMasterLen);
;;;104    				u8Temp = g_u8FromMasterLen;	//copy data for TX display purpose
;;;105    				cnt = _state_DEFAULT_;	//reset flag
;;;106    			}
;;;107    			else if (res == SLAVE_RECEIVE_DATA_ACK)
;;;108    			{
;;;109    				// continue to get data
;;;110    				g_u8FromMasterData[g_u8FromMasterLen++] =  *InData;
;;;111    			}
;;;112    			break;
;;;113    
;;;114    		case _state_TRANSMIT_TX_:
;;;115    			if (res == SLAVE_TRANSMIT_ADDRESS_ACK)	
;;;116    			{
;;;117    				// first TX byte
;;;118    
;;;119    				//swap the data 
;;;120    				for (i = 0; i < u8Temp; i++)
;;;121    				{
;;;122    					g_u8ToMasterData[(u8Temp-1)-i] = g_u8FromMasterData[i];
00002a  4631              MOV      r1,r6
00002c  3940              SUBS     r1,r1,#0x40
00002e  28a8              CMP      r0,#0xa8              ;115
000030  d02f              BEQ      |L4.146|
;;;123    				}
;;;124    				
;;;125    				*OutData = g_u8ToMasterData[g_u8ToMasterLen++];
;;;126    			}
;;;127    			else if (res == SLAVE_TRANSMIT_DATA_NACK)	
000032  28c0              CMP      r0,#0xc0
000034  d040              BEQ      |L4.184|
;;;128    			{
;;;129    				// end of TX
;;;130    
;;;131    				printf("g_u8ToMasterLen = %d\r\n\r\n" , g_u8ToMasterLen);
;;;132    				cnt = _state_DEFAULT_;	//reset flag
;;;133    			}
;;;134    			else if (res == SLAVE_TRANSMIT_DATA_ACK)
000036  28b8              CMP      r0,#0xb8
000038  d037              BEQ      |L4.170|
                  |L4.58|
;;;135    			{
;;;136    				// continue to send data
;;;137    				*OutData = g_u8ToMasterData[g_u8ToMasterLen++];
;;;138    			}
;;;139    			break;
;;;140    
;;;141    			
;;;142    	}
;;;143    }
00003a  bdf8              POP      {r3-r7,pc}
                  |L4.60|
00003c  2880              CMP      r0,#0x80              ;70
00003e  d1fc              BNE      |L4.58|
000040  7820              LDRB     r0,[r4,#0]            ;73  ; g_u8DataLen_s
000042  2801              CMP      r0,#1                 ;73
000044  d104              BNE      |L4.80|
000046  7a21              LDRB     r1,[r4,#8]            ;75  ; slave_buff_addr
000048  70e1              STRB     r1,[r4,#3]            ;75
00004a  a020              ADR      r0,|L4.204|
00004c  f7fffffe          BL       __2printf
                  |L4.80|
000050  2002              MOVS     r0,#2                 ;78
000052  e00b              B        |L4.108|
                  |L4.84|
000054  2880              CMP      r0,#0x80              ;83
000056  d003              BEQ      |L4.96|
000058  28a0              CMP      r0,#0xa0              ;90
00005a  d1ee              BNE      |L4.58|
00005c  2004              MOVS     r0,#4                 ;94
00005e  e005              B        |L4.108|
                  |L4.96|
000060  78a0              LDRB     r0,[r4,#2]            ;87  ; g_u8FromMasterLen
000062  7809              LDRB     r1,[r1,#0]            ;87
000064  5431              STRB     r1,[r6,r0]            ;87
000066  1c40              ADDS     r0,r0,#1              ;87
000068  70a0              STRB     r0,[r4,#2]            ;87
00006a  2003              MOVS     r0,#3                 ;88
                  |L4.108|
00006c  7160              STRB     r0,[r4,#5]            ;78
                  |L4.110|
00006e  bdf8              POP      {r3-r7,pc}
                  |L4.112|
000070  28a0              CMP      r0,#0xa0              ;99
000072  d007              BEQ      |L4.132|
000074  2880              CMP      r0,#0x80              ;107
000076  d1fa              BNE      |L4.110|
000078  78a0              LDRB     r0,[r4,#2]            ;110  ; g_u8FromMasterLen
00007a  7809              LDRB     r1,[r1,#0]            ;110
00007c  5431              STRB     r1,[r6,r0]            ;110
00007e  1c40              ADDS     r0,r0,#1              ;110
000080  70a0              STRB     r0,[r4,#2]            ;110
000082  bdf8              POP      {r3-r7,pc}
                  |L4.132|
000084  78a1              LDRB     r1,[r4,#2]            ;103  ; g_u8FromMasterLen
000086  a019              ADR      r0,|L4.236|
000088  f7fffffe          BL       __2printf
00008c  78a0              LDRB     r0,[r4,#2]            ;104  ; g_u8FromMasterLen
00008e  7120              STRB     r0,[r4,#4]            ;104
000090  e016              B        |L4.192|
                  |L4.146|
000092  480c              LDR      r0,|L4.196|
000094  7900              LDRB     r0,[r0,#4]            ;61
000096  e006              B        |L4.166|
                  |L4.152|
000098  1ac7              SUBS     r7,r0,r3              ;122
00009a  187f              ADDS     r7,r7,r1              ;122
00009c  5cf5              LDRB     r5,[r6,r3]            ;122
00009e  3f20              SUBS     r7,r7,#0x20           ;122
0000a0  1c5b              ADDS     r3,r3,#1              ;122
0000a2  77fd              STRB     r5,[r7,#0x1f]         ;122
0000a4  b2db              UXTB     r3,r3                 ;120
                  |L4.166|
0000a6  4283              CMP      r3,r0                 ;120
0000a8  d3f6              BCC      |L4.152|
                  |L4.170|
0000aa  7860              LDRB     r0,[r4,#1]            ;125  ; g_u8ToMasterLen
0000ac  5c08              LDRB     r0,[r1,r0]            ;125
0000ae  7010              STRB     r0,[r2,#0]            ;125
0000b0  7860              LDRB     r0,[r4,#1]            ;125  ; g_u8ToMasterLen
0000b2  1c40              ADDS     r0,r0,#1              ;125
0000b4  7060              STRB     r0,[r4,#1]            ;125
0000b6  bdf8              POP      {r3-r7,pc}
                  |L4.184|
0000b8  7861              LDRB     r1,[r4,#1]            ;131  ; g_u8ToMasterLen
0000ba  a013              ADR      r0,|L4.264|
0000bc  f7fffffe          BL       __2printf
                  |L4.192|
0000c0  7165              STRB     r5,[r4,#5]            ;105
0000c2  bdf8              POP      {r3-r7,pc}
;;;144    
                          ENDP

                  |L4.196|
                          DCD      ||.data||
                  |L4.200|
                          DCD      ||.bss||+0x140
                  |L4.204|
0000cc  736c6176          DCB      "slave_register_addr = 0x%2X\r\n",0
0000d0  655f7265
0000d4  67697374
0000d8  65725f61
0000dc  64647220
0000e0  3d203078
0000e4  2532580d
0000e8  0a00    
0000ea  00                DCB      0
0000eb  00                DCB      0
                  |L4.236|
0000ec  675f7538          DCB      "g_u8FromMasterLen = %d\r\n",0
0000f0  46726f6d
0000f4  4d617374
0000f8  65724c65
0000fc  6e203d20
000100  25640d0a
000104  00      
000105  00                DCB      0
000106  00                DCB      0
000107  00                DCB      0
                  |L4.264|
000108  675f7538          DCB      "g_u8ToMasterLen = %d\r\n\r\n",0
00010c  546f4d61
000110  73746572
000114  4c656e20
000118  3d202564
00011c  0d0a0d0a
000120  00      
000121  00                DCB      0
000122  00                DCB      0
000123  00                DCB      0

                          AREA ||i.I2Cx_Slave_example||, CODE, READONLY, ALIGN=2

                  I2Cx_Slave_example PROC
;;;378    
;;;379    void I2Cx_Slave_example (void)
000000  b510              PUSH     {r4,lr}
;;;380    {
;;;381    //	static uint32_t cnt = 0;
;;;382    
;;;383    	printf("I2Cx_Slave_example start\r\n");
000002  a003              ADR      r0,|L5.16|
000004  f7fffffe          BL       __2printf
;;;384    //    I2Cx_Slave_Init();
;;;385          
;;;386    		
;;;387    	/* I2C function to write data to slave */
;;;388    	I2Cx_Slave_HandlerFn = I2Cx_SlaveTRx;
000008  4909              LDR      r1,|L5.48|
00000a  4808              LDR      r0,|L5.44|
00000c  60c8              STR      r0,[r1,#0xc]  ; I2Cx_Slave_HandlerFn
;;;389    
;;;390    }
00000e  bd10              POP      {r4,pc}
;;;391    
                          ENDP

                  |L5.16|
000010  49324378          DCB      "I2Cx_Slave_example start\r\n",0
000014  5f536c61
000018  76655f65
00001c  78616d70
000020  6c652073
000024  74617274
000028  0d0a00  
00002b  00                DCB      0
                  |L5.44|
                          DCD      I2Cx_SlaveTRx
                  |L5.48|
                          DCD      ||.data||

                          AREA ||i.__I2Cx_Slave_LogBuffer__||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  __I2Cx_Slave_LogBuffer__ PROC
;;;38     /*---------------------------------------------------------------------------------------------------------*/
;;;39     void __I2Cx_Slave_LogBuffer__(uint8_t res , uint8_t d)
000000  b510              PUSH     {r4,lr}
;;;40     {
;;;41     	#if defined (DEBUG_LOG_SLAVE_LV2)
;;;42     	printf("0x%2X : 0x%2X\r\n" , res , d);
000002  460a              MOV      r2,r1
000004  4601              MOV      r1,r0
000006  a002              ADR      r0,|L6.16|
000008  f7fffffe          BL       __2printf
;;;43     	#endif	
;;;44     }
00000c  bd10              POP      {r4,pc}
;;;45     
                          ENDP

00000e  0000              DCW      0x0000
                  |L6.16|
000010  30782532          DCB      "0x%2X : 0x%2X\r\n",0
000014  58203a20
000018  30782532
00001c  580d0a00

                          AREA ||i.__I2Cx_Slave_Log__||, CODE, READONLY, ALIGN=1

                  __I2Cx_Slave_Log__ PROC
;;;45     
;;;46     void __I2Cx_Slave_Log__(uint32_t u32Status)
000000  4770              BX       lr
;;;47     {
;;;48     	#if defined (DEBUG_LOG_SLAVE_LV1)
;;;49         printf("Status 0x%x is processed\n", u32Status);
;;;50     	#endif
;;;51     }
;;;52     
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  g_u8SlvData
                          %        256
                  g_u8ToMasterData
                          %        64
                  g_u8FromMasterData
                          %        256

                          AREA ||.data||, DATA, ALIGN=2

                  g_u8DataLen_s
000000  00                DCB      0x00
                  g_u8ToMasterLen
000001  00                DCB      0x00
                  g_u8FromMasterLen
000002  00                DCB      0x00
                  slave_register_addr
000003  00                DCB      0x00
                  u8Temp
000004  00                DCB      0x00
                  ||cnt||
000005  000000            DCB      0x00,0x00,0x00
                  slave_buff_addr
                          DCD      0x00000000
                  I2Cx_Slave_HandlerFn
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\i2c_slave.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___11_i2c_slave_c_7e27db3b____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___11_i2c_slave_c_7e27db3b____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___11_i2c_slave_c_7e27db3b____REVSH|
#line 402
|__asm___11_i2c_slave_c_7e27db3b____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
