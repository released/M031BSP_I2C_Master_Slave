; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\i2c_master.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\i2c_master.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M031\Include -I..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 -DBUILD_MASTER_I2C --omf_browse=.\obj\i2c_master.crf ..\i2c_master.c]
                          THUMB

                          AREA ||i.I2C0_IRQHandler||, CODE, READONLY, ALIGN=2

                  I2C0_IRQHandler PROC
;;;28     
;;;29     void I2Cx_Master_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;30     {
;;;31         uint32_t u32Status;
;;;32     
;;;33         u32Status = I2C_GET_STATUS(MASTER_I2C);
000002  4908              LDR      r1,|L1.36|
000004  68c8              LDR      r0,[r1,#0xc]
;;;34     
;;;35         if (I2C_GET_TIMEOUT_FLAG(MASTER_I2C))
000006  694a              LDR      r2,[r1,#0x14]
000008  43d2              MVNS     r2,r2
00000a  07d2              LSLS     r2,r2,#31
00000c  d006              BEQ      |L1.28|
;;;36         {
;;;37             /* Clear I2C Timeout Flag */
;;;38             I2C_ClearTimeoutFlag(MASTER_I2C);                   
;;;39         }    
;;;40         else
;;;41         {
;;;42             if (I2Cx_Master_HandlerFn != NULL)
00000e  4906              LDR      r1,|L1.40|
000010  688a              LDR      r2,[r1,#8]  ; I2Cx_Master_HandlerFn
000012  2a00              CMP      r2,#0
000014  d001              BEQ      |L1.26|
;;;43                 I2Cx_Master_HandlerFn(u32Status);
000016  6889              LDR      r1,[r1,#8]  ; I2Cx_Master_HandlerFn
000018  4788              BLX      r1
                  |L1.26|
;;;44         }
;;;45     }
00001a  bd10              POP      {r4,pc}
                  |L1.28|
00001c  4608              MOV      r0,r1                 ;38
00001e  f7fffffe          BL       I2C_ClearTimeoutFlag
000022  bd10              POP      {r4,pc}
;;;46     
                          ENDP

                  |L1.36|
                          DCD      0x40080000
                  |L1.40|
                          DCD      ||.data||

                          AREA ||i.I2Cx_MasterRx_multi||, CODE, READONLY, ALIGN=2

                  I2Cx_MasterRx_multi PROC
;;;46     
;;;47     void I2Cx_MasterRx_multi(uint32_t u32Status)
000000  b5f8              PUSH     {r3-r7,lr}
;;;48     {
;;;49         if(u32Status == MASTER_START_TRANSMIT) //0x08                       	/* START has been transmitted and prepare SLA+W */
;;;50         {
;;;51             I2C_SET_DATA(MASTER_I2C, (g_u8DeviceAddr_m << 1));    				/* Write SLA+W to Register I2CDAT */
;;;52             I2C_SET_CONTROL_REG(MASTER_I2C, I2C_CTL_SI);
000002  243c              MOVS     r4,#0x3c
000004  4e2a              LDR      r6,|L2.176|
000006  4d2b              LDR      r5,|L2.180|
000008  2808              CMP      r0,#8                 ;49
00000a  d019              BEQ      |L2.64|
;;;53     
;;;54     		I2Cx_Master_LOG(u32Status);
;;;55         }
;;;56         else if(u32Status == MASTER_TRANSMIT_ADDRESS_ACK) //0x18        			/* SLA+W has been transmitted and ACK has been received */
00000c  2818              CMP      r0,#0x18
00000e  d01a              BEQ      |L2.70|
;;;57         {
;;;58             I2C_SET_DATA(MASTER_I2C, g_au8Reg);
;;;59             I2C_SET_CONTROL_REG(MASTER_I2C, I2C_CTL_SI);
;;;60     		
;;;61     		I2Cx_Master_LOG(u32Status);
;;;62         }
;;;63         else if(u32Status == MASTER_TRANSMIT_ADDRESS_NACK) //0x20            	/* SLA+W has been transmitted and NACK has been received */
000010  2820              CMP      r0,#0x20
000012  d01d              BEQ      |L2.80|
;;;64         {
;;;65             I2C_SET_CONTROL_REG(MASTER_I2C, I2C_CTL_SI | I2C_CTL_STA | I2C_CTL_STO);
;;;66     
;;;67     //        I2C_STOP(MASTER_I2C);
;;;68     //        I2C_START(MASTER_I2C);
;;;69     		
;;;70     		I2Cx_Master_LOG(u32Status);
;;;71         }
;;;72         else if(u32Status == MASTER_TRANSMIT_DATA_ACK) //0x28                  	/* DATA has been transmitted and ACK has been received */
;;;73         {
;;;74             if (rawlenth > 0)
;;;75     			I2C_SET_CONTROL_REG(MASTER_I2C, I2C_CTL_SI | I2C_CTL_STA);				//repeat start
;;;76     		else
;;;77     		{
;;;78     			I2C_SET_CONTROL_REG(MASTER_I2C, I2C_CTL_SI | I2C_CTL_STO);
;;;79     			g_u8EndFlag = 1;
000014  2701              MOVS     r7,#1
000016  2828              CMP      r0,#0x28              ;72
000018  d01e              BEQ      |L2.88|
;;;80     		}
;;;81     		
;;;82     		I2Cx_Master_LOG(u32Status);
;;;83         }
;;;84         else if(u32Status == MASTER_REPEAT_START) //0x10                  		/* Repeat START has been transmitted and prepare SLA+R */
00001a  2810              CMP      r0,#0x10
00001c  d029              BEQ      |L2.114|
;;;85         {
;;;86             I2C_SET_DATA(MASTER_I2C, ((g_u8DeviceAddr_m << 1) | 0x01));   		/* Write SLA+R to Register I2CDAT */
;;;87             I2C_SET_CONTROL_REG(MASTER_I2C, I2C_CTL_SI);
;;;88     		
;;;89     		I2Cx_Master_LOG(u32Status);
;;;90         }
;;;91         else if(u32Status == MASTER_RECEIVE_ADDRESS_ACK) //0x40                	/* SLA+R has been transmitted and ACK has been received */
00001e  2840              CMP      r0,#0x40
000020  d02b              BEQ      |L2.122|
;;;92         {
;;;93     		if (rawlenth > 1)
;;;94     			I2C_SET_CONTROL_REG(MASTER_I2C, I2C_CTL_SI | I2C_CTL_AA);
;;;95     		else
;;;96     			I2C_SET_CONTROL_REG(MASTER_I2C, I2C_CTL_SI);
;;;97     
;;;98     		I2Cx_Master_LOG(u32Status);
;;;99         }
;;;100    	else if(u32Status == MASTER_RECEIVE_DATA_ACK) //0x50                 	/* DATA has been received and ACK has been returned */
000022  2850              CMP      r0,#0x50
000024  d02d              BEQ      |L2.130|
;;;101        {
;;;102            g_au8Buffer[g_u8DataLen_m++] = (unsigned char) I2C_GetData(MASTER_I2C);
;;;103            if (g_u8DataLen_m < (rawlenth-1))
;;;104    		{
;;;105    			I2C_SET_CONTROL_REG(MASTER_I2C, I2C_CTL_SI | I2C_CTL_AA);
;;;106    		}
;;;107    		else
;;;108    		{
;;;109    			I2C_SET_CONTROL_REG(MASTER_I2C, I2C_CTL_SI);
;;;110    		}
;;;111    		
;;;112    		I2Cx_Master_LOG(u32Status);
;;;113        }
;;;114        else if(u32Status == MASTER_RECEIVE_DATA_NACK) //0x58                  	/* DATA has been received and NACK has been returned */
000026  2858              CMP      r0,#0x58
000028  d111              BNE      |L2.78|
;;;115        {
;;;116            g_au8Buffer[g_u8DataLen_m++] = (unsigned char) I2C_GetData(MASTER_I2C);
00002a  4628              MOV      r0,r5
00002c  f7fffffe          BL       I2C_GetData
000030  4601              MOV      r1,r0
000032  78b0              LDRB     r0,[r6,#2]  ; g_u8DataLen_m
000034  6932              LDR      r2,[r6,#0x10]  ; g_au8Buffer
000036  1812              ADDS     r2,r2,r0
000038  1c40              ADDS     r0,r0,#1
00003a  70b0              STRB     r0,[r6,#2]
00003c  7011              STRB     r1,[r2,#0]
;;;117            I2C_SET_CONTROL_REG(MASTER_I2C, I2C_CTL_SI | I2C_CTL_STO);
;;;118            g_u8EndFlag = 1;
;;;119    
;;;120    		
;;;121    		I2Cx_Master_LOG(u32Status);
00003e  e012              B        |L2.102|
                  |L2.64|
000040  7870              LDRB     r0,[r6,#1]            ;51  ; g_u8DeviceAddr_m
000042  0040              LSLS     r0,r0,#1              ;51
000044  e000              B        |L2.72|
                  |L2.70|
000046  7930              LDRB     r0,[r6,#4]            ;58  ; g_au8Reg
                  |L2.72|
000048  60a8              STR      r0,[r5,#8]            ;51
00004a  e02d              B        |L2.168|
                  |L2.76|
00004c  6028              STR      r0,[r5,#0]            ;52
                  |L2.78|
;;;122        }
;;;123        else
;;;124        {
;;;125    		#if defined (DEBUG_LOG_MASTER_LV1)
;;;126            /* TO DO */
;;;127            printf("I2Cx_MasterRx_multi Status 0x%x is NOT processed\n", u32Status);
;;;128    		#endif
;;;129        }
;;;130    }
00004e  bdf8              POP      {r3-r7,pc}
                  |L2.80|
000050  6828              LDR      r0,[r5,#0]            ;65
000052  43a0              BICS     r0,r0,r4              ;65
000054  3038              ADDS     r0,r0,#0x38           ;65
000056  e7f9              B        |L2.76|
                  |L2.88|
000058  78f0              LDRB     r0,[r6,#3]            ;74  ; rawlenth
00005a  2800              CMP      r0,#0                 ;74
00005c  d003              BEQ      |L2.102|
00005e  6828              LDR      r0,[r5,#0]            ;75
000060  43a0              BICS     r0,r0,r4              ;75
000062  3028              ADDS     r0,r0,#0x28           ;75
000064  e7f2              B        |L2.76|
                  |L2.102|
000066  6828              LDR      r0,[r5,#0]            ;78
000068  43a0              BICS     r0,r0,r4              ;78
00006a  3018              ADDS     r0,r0,#0x18           ;78
00006c  6028              STR      r0,[r5,#0]            ;78
00006e  7037              STRB     r7,[r6,#0]            ;79
000070  bdf8              POP      {r3-r7,pc}
                  |L2.114|
000072  7870              LDRB     r0,[r6,#1]            ;86  ; g_u8DeviceAddr_m
000074  0040              LSLS     r0,r0,#1              ;86
000076  1c40              ADDS     r0,r0,#1              ;86
000078  e7e6              B        |L2.72|
                  |L2.122|
00007a  78f0              LDRB     r0,[r6,#3]            ;93  ; rawlenth
00007c  2801              CMP      r0,#1                 ;93
00007e  d80f              BHI      |L2.160|
000080  e012              B        |L2.168|
                  |L2.130|
000082  4628              MOV      r0,r5                 ;102
000084  f7fffffe          BL       I2C_GetData
000088  4601              MOV      r1,r0                 ;102
00008a  78b0              LDRB     r0,[r6,#2]            ;102  ; g_u8DataLen_m
00008c  6932              LDR      r2,[r6,#0x10]         ;102  ; g_au8Buffer
00008e  1812              ADDS     r2,r2,r0              ;102
000090  1c40              ADDS     r0,r0,#1              ;102
000092  70b0              STRB     r0,[r6,#2]            ;102
000094  7011              STRB     r1,[r2,#0]            ;102
000096  78b1              LDRB     r1,[r6,#2]            ;103  ; g_u8DataLen_m
000098  78f0              LDRB     r0,[r6,#3]            ;103  ; rawlenth
00009a  1e40              SUBS     r0,r0,#1              ;103
00009c  4281              CMP      r1,r0                 ;103
00009e  da03              BGE      |L2.168|
                  |L2.160|
0000a0  6828              LDR      r0,[r5,#0]            ;105
0000a2  43a0              BICS     r0,r0,r4              ;105
0000a4  300c              ADDS     r0,r0,#0xc            ;105
0000a6  e7d1              B        |L2.76|
                  |L2.168|
0000a8  6828              LDR      r0,[r5,#0]            ;109
0000aa  43a0              BICS     r0,r0,r4              ;109
0000ac  3008              ADDS     r0,r0,#8              ;109
0000ae  e7cd              B        |L2.76|
;;;131    
                          ENDP

                  |L2.176|
                          DCD      ||.data||
                  |L2.180|
                          DCD      0x40080000

                          AREA ||i.I2Cx_MasterTx_multi||, CODE, READONLY, ALIGN=2

                  I2Cx_MasterTx_multi PROC
;;;131    
;;;132    void I2Cx_MasterTx_multi(uint32_t u32Status)
000000  b510              PUSH     {r4,lr}
;;;133    {
;;;134        if(u32Status == MASTER_START_TRANSMIT)  //0x08                     	/* START has been transmitted */
;;;135        {
;;;136            I2C_SET_DATA(MASTER_I2C, g_u8DeviceAddr_m << 1);    			/* Write SLA+W to Register I2CDAT */
000002  491d              LDR      r1,|L3.120|
;;;137            I2C_SET_CONTROL_REG(MASTER_I2C, I2C_CTL_SI);
000004  223c              MOVS     r2,#0x3c
000006  4b1d              LDR      r3,|L3.124|
000008  2808              CMP      r0,#8                 ;134
00000a  d011              BEQ      |L3.48|
;;;138    
;;;139    		I2Cx_Master_LOG(u32Status);
;;;140    		
;;;141        }
;;;142        else if(u32Status == MASTER_TRANSMIT_ADDRESS_ACK)  //0x18           	/* SLA+W has been transmitted and ACK has been received */
00000c  2818              CMP      r0,#0x18
00000e  d012              BEQ      |L3.54|
;;;143        {
;;;144            I2C_SET_DATA(MASTER_I2C, g_au8Reg);
;;;145            I2C_SET_CONTROL_REG(MASTER_I2C, I2C_CTL_SI);
;;;146    		
;;;147    		I2Cx_Master_LOG(u32Status);	
;;;148        }
;;;149        else if(u32Status == MASTER_TRANSMIT_ADDRESS_NACK) //0x20           /* SLA+W has been transmitted and NACK has been received */
000010  2820              CMP      r0,#0x20
000012  d017              BEQ      |L3.68|
;;;150        {
;;;151            I2C_SET_CONTROL_REG(MASTER_I2C, I2C_CTL_SI | I2C_CTL_STA | I2C_CTL_STO);
;;;152    
;;;153    //        I2C_STOP(MASTER_I2C);
;;;154    //        I2C_START(MASTER_I2C);
;;;155    
;;;156    		I2Cx_Master_LOG(u32Status);	
;;;157        }
;;;158        else if(u32Status == MASTER_TRANSMIT_DATA_ACK) //0x28              	/* DATA has been transmitted and ACK has been received */
000014  2828              CMP      r0,#0x28
000016  d019              BEQ      |L3.76|
;;;159        {
;;;160            if(g_u8DataLen_m < rawlenth)
;;;161            {
;;;162                I2C_SET_DATA(MASTER_I2C, g_au8Buffer[g_u8DataLen_m++]);
;;;163                I2C_SET_CONTROL_REG(MASTER_I2C, I2C_CTL_SI);
;;;164            }
;;;165            else
;;;166            {
;;;167                I2C_SET_CONTROL_REG(MASTER_I2C, I2C_CTL_SI | I2C_CTL_STO);
;;;168                g_u8EndFlag = 1;
;;;169            }
;;;170    
;;;171    		I2Cx_Master_LOG(u32Status);		
;;;172        }
;;;173        else if(u32Status == MASTER_ARBITRATION_LOST) //0x38
000018  2838              CMP      r0,#0x38
00001a  d029              BEQ      |L3.112|
;;;174        {
;;;175    		I2C_SET_CONTROL_REG(MASTER_I2C, I2C_CTL_STA_SI_AA);
;;;176    
;;;177    		I2Cx_Master_LOG(u32Status);		
;;;178        }
;;;179        else if(u32Status == BUS_ERROR) //0x00
00001c  2800              CMP      r0,#0
00001e  d110              BNE      |L3.66|
;;;180        {
;;;181    		I2C_SET_CONTROL_REG(MASTER_I2C, I2C_CTL_STO_SI_AA);
000020  6808              LDR      r0,[r1,#0]
000022  4390              BICS     r0,r0,r2
000024  301c              ADDS     r0,r0,#0x1c
000026  6008              STR      r0,[r1,#0]
;;;182    		I2C_SET_CONTROL_REG(MASTER_I2C, I2C_CTL_SI_AA);
000028  6808              LDR      r0,[r1,#0]
00002a  4390              BICS     r0,r0,r2
00002c  300c              ADDS     r0,r0,#0xc
;;;183    		
;;;184    		I2Cx_Master_LOG(u32Status);		
00002e  e007              B        |L3.64|
                  |L3.48|
000030  7858              LDRB     r0,[r3,#1]            ;136  ; g_u8DeviceAddr_m
000032  0040              LSLS     r0,r0,#1              ;136
000034  e000              B        |L3.56|
                  |L3.54|
000036  7918              LDRB     r0,[r3,#4]            ;144  ; g_au8Reg
                  |L3.56|
000038  6088              STR      r0,[r1,#8]            ;136
00003a  6808              LDR      r0,[r1,#0]            ;137
00003c  4390              BICS     r0,r0,r2              ;137
00003e  3008              ADDS     r0,r0,#8              ;137
                  |L3.64|
000040  6008              STR      r0,[r1,#0]            ;137
                  |L3.66|
;;;185        }		
;;;186        else
;;;187        {
;;;188    		#if defined (DEBUG_LOG_MASTER_LV1)
;;;189            /* TO DO */
;;;190            printf("I2Cx_MasterTx_multi Status 0x%x is NOT processed\n", u32Status);
;;;191    		#endif
;;;192        }
;;;193    }
000042  bd10              POP      {r4,pc}
                  |L3.68|
000044  6808              LDR      r0,[r1,#0]            ;151
000046  4390              BICS     r0,r0,r2              ;151
000048  3038              ADDS     r0,r0,#0x38           ;151
00004a  e7f9              B        |L3.64|
                  |L3.76|
00004c  7898              LDRB     r0,[r3,#2]            ;160  ; g_u8DataLen_m
00004e  78dc              LDRB     r4,[r3,#3]            ;160  ; rawlenth
000050  42a0              CMP      r0,r4                 ;160
000052  d206              BCS      |L3.98|
000054  7898              LDRB     r0,[r3,#2]            ;162  ; g_u8DataLen_m
000056  691c              LDR      r4,[r3,#0x10]         ;162  ; g_au8Buffer
000058  1824              ADDS     r4,r4,r0              ;162
00005a  1c40              ADDS     r0,r0,#1              ;162
00005c  7098              STRB     r0,[r3,#2]            ;162
00005e  7820              LDRB     r0,[r4,#0]            ;162
000060  e7ea              B        |L3.56|
                  |L3.98|
000062  6808              LDR      r0,[r1,#0]            ;167
000064  4390              BICS     r0,r0,r2              ;167
000066  3018              ADDS     r0,r0,#0x18           ;167
000068  6008              STR      r0,[r1,#0]            ;167
00006a  2001              MOVS     r0,#1                 ;168
00006c  7018              STRB     r0,[r3,#0]            ;168
00006e  bd10              POP      {r4,pc}
                  |L3.112|
000070  6808              LDR      r0,[r1,#0]            ;175
000072  4390              BICS     r0,r0,r2              ;175
000074  302c              ADDS     r0,r0,#0x2c           ;175
000076  e7e3              B        |L3.64|
;;;194    
                          ENDP

                  |L3.120|
                          DCD      0x40080000
                  |L3.124|
                          DCD      ||.data||

                          AREA ||i.I2Cx_Master_Init||, CODE, READONLY, ALIGN=2

                  I2Cx_Master_Init PROC
;;;239    
;;;240    void I2Cx_Master_Init(void)
000000  b510              PUSH     {r4,lr}
;;;241    {    
;;;242        /* Open I2C module and set bus clock */
;;;243        I2C_Open(MASTER_I2C, 100000);
000002  4c13              LDR      r4,|L4.80|
000004  4911              LDR      r1,|L4.76|
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       I2C_Open
;;;244        
;;;245         /* Set I2C 4 Slave Addresses */            
;;;246        I2C_SetSlaveAddr(MASTER_I2C, 0, 0x15, 0);   /* Slave Address : 0x15 */
00000c  2300              MOVS     r3,#0
00000e  2215              MOVS     r2,#0x15
000010  4619              MOV      r1,r3
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       I2C_SetSlaveAddr
;;;247        I2C_SetSlaveAddr(MASTER_I2C, 1, 0x35, 0);   /* Slave Address : 0x35 */
000018  2300              MOVS     r3,#0
00001a  2235              MOVS     r2,#0x35
00001c  2101              MOVS     r1,#1
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       I2C_SetSlaveAddr
;;;248        I2C_SetSlaveAddr(MASTER_I2C, 2, 0x55, 0);   /* Slave Address : 0x55 */
000024  2300              MOVS     r3,#0
000026  2255              MOVS     r2,#0x55
000028  2102              MOVS     r1,#2
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       I2C_SetSlaveAddr
;;;249        I2C_SetSlaveAddr(MASTER_I2C, 3, 0x75, 0);   /* Slave Address : 0x75 */
000030  2300              MOVS     r3,#0
000032  2275              MOVS     r2,#0x75
000034  2103              MOVS     r1,#3
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       I2C_SetSlaveAddr
;;;250    
;;;251        /* Enable I2C interrupt */
;;;252    	#if defined (MASTER_I2C_USE_IRQ)
;;;253        I2C_EnableInt(MASTER_I2C);
00003c  4620              MOV      r0,r4
00003e  f7fffffe          BL       I2C_EnableInt
000042  2001              MOVS     r0,#1
000044  4903              LDR      r1,|L4.84|
000046  0480              LSLS     r0,r0,#18
000048  6008              STR      r0,[r1,#0]
;;;254        NVIC_EnableIRQ(MASTER_I2C_IRQn);
;;;255    	#endif
;;;256    
;;;257    }
00004a  bd10              POP      {r4,pc}
;;;258    
                          ENDP

                  |L4.76|
                          DCD      0x000186a0
                  |L4.80|
                          DCD      0x40080000
                  |L4.84|
                          DCD      0xe000e100

                          AREA ||i.I2Cx_Master_LOG||, CODE, READONLY, ALIGN=1

                  I2Cx_Master_LOG PROC
;;;21     /*---------------------------------------------------------------------------------------------------------*/
;;;22     void I2Cx_Master_LOG(uint32_t u32Status)
000000  4770              BX       lr
;;;23     {
;;;24     	#if defined (DEBUG_LOG_MASTER_LV1)
;;;25         printf("Status 0x%x is processed\n", u32Status);
;;;26     	#endif
;;;27     }
;;;28     
                          ENDP


                          AREA ||i.I2Cx_Master_example||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_x
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_longlong_hex
                  I2Cx_Master_example PROC
;;;258    
;;;259    void I2Cx_Master_example (void)
000000  b5f0              PUSH     {r4-r7,lr}
;;;260    {
000002  b089              SUB      sp,sp,#0x24
;;;261    	static uint32_t cnt = 0;	
;;;262    	uint8_t u8RxData[16] = {0};
000004  2400              MOVS     r4,#0
000006  9400              STR      r4,[sp,#0]
000008  9401              STR      r4,[sp,#4]
00000a  9402              STR      r4,[sp,#8]
;;;263    	uint8_t u8TxData[16] = {0};
00000c  9403              STR      r4,[sp,#0xc]
00000e  9404              STR      r4,[sp,#0x10]
000010  9405              STR      r4,[sp,#0x14]
000012  9406              STR      r4,[sp,#0x18]
;;;264    
;;;265    	uint8_t addr,reg;
;;;266    	uint32_t i;	
;;;267    	uint16_t len;
;;;268    
;;;269    	printf("I2Cx_Master_example start\r\n");
000014  a02c              ADR      r0,|L6.200|
000016  9407              STR      r4,[sp,#0x1c]
000018  f7fffffe          BL       __2printf
;;;270    
;;;271    //	I2Cx_Master_Init();
;;;272    
;;;273    	addr = 0x15;
00001c  2615              MOVS     r6,#0x15
;;;274    	reg = 0x66;
00001e  2566              MOVS     r5,#0x66
;;;275    	len = 10;
000020  270a              MOVS     r7,#0xa
;;;276    
;;;277    	//clear data
;;;278    	for(i = 0; i < 16; i++)
000022  2000              MOVS     r0,#0
000024  a904              ADD      r1,sp,#0x10           ;263
                  |L6.38|
;;;279    	{
;;;280    		u8TxData[i] = 0;
000026  540c              STRB     r4,[r1,r0]
000028  1c40              ADDS     r0,r0,#1
00002a  2810              CMP      r0,#0x10              ;278
00002c  d3fb              BCC      |L6.38|
;;;281    	}
;;;282    
;;;283    	//fill data
;;;284    	u8TxData[0] = 0x12 ;
00002e  2012              MOVS     r0,#0x12
000030  4669              MOV      r1,sp
000032  7408              STRB     r0,[r1,#0x10]
;;;285    	u8TxData[1] = 0x34 ;	
000034  2034              MOVS     r0,#0x34
000036  7448              STRB     r0,[r1,#0x11]
;;;286    	u8TxData[2] = 0x56 ;
000038  2056              MOVS     r0,#0x56
00003a  7488              STRB     r0,[r1,#0x12]
;;;287    	u8TxData[3] = 0x78 ;
00003c  2078              MOVS     r0,#0x78
00003e  74c8              STRB     r0,[r1,#0x13]
;;;288    	u8TxData[4] = 0x90 ;
000040  2090              MOVS     r0,#0x90
000042  7508              STRB     r0,[r1,#0x14]
;;;289    	u8TxData[5] = 0xAB ;
000044  20ab              MOVS     r0,#0xab
000046  7548              STRB     r0,[r1,#0x15]
;;;290    	u8TxData[6] = 0xCD ;
000048  20cd              MOVS     r0,#0xcd
00004a  7588              STRB     r0,[r1,#0x16]
;;;291    	u8TxData[7] = 0xEF ;
00004c  20ef              MOVS     r0,#0xef
00004e  75c8              STRB     r0,[r1,#0x17]
;;;292    	u8TxData[8] = 0x99 ;
000050  2099              MOVS     r0,#0x99
000052  7608              STRB     r0,[r1,#0x18]
;;;293    	u8TxData[9] = 0xFE ;
000054  20fe              MOVS     r0,#0xfe
000056  7648              STRB     r0,[r1,#0x19]
;;;294    
;;;295    	#if defined (MASTER_I2C_USE_IRQ)
;;;296    	I2Cx_Write_Multi_ToSlave(addr,reg,u8TxData,len);
000058  463b              MOV      r3,r7
00005a  aa04              ADD      r2,sp,#0x10
00005c  4629              MOV      r1,r5
00005e  4630              MOV      r0,r6
000060  f7fffffe          BL       I2Cx_Write_Multi_ToSlave
;;;297    	#elif defined (MASTER_I2C_USE_POLLING)
;;;298    	I2C_WriteMultiBytesOneReg(MASTER_I2C, addr, reg, u8TxData, len);		
;;;299    	#endif
;;;300    	
;;;301    	printf("I2Cx_Write finish\r\n");
000064  a01f              ADR      r0,|L6.228|
000066  f7fffffe          BL       __2printf
;;;302    	printf("addr : 0x%2X, reg : 0x%2X , data (%2d) : \r\n",addr,reg,cnt++);
00006a  4823              LDR      r0,|L6.248|
00006c  462a              MOV      r2,r5
00006e  68c3              LDR      r3,[r0,#0xc]  ; cnt
000070  1c59              ADDS     r1,r3,#1
000072  60c1              STR      r1,[r0,#0xc]  ; cnt
000074  4631              MOV      r1,r6
000076  a021              ADR      r0,|L6.252|
000078  f7fffffe          BL       __2printf
;;;303    	
;;;304    	//clear data
;;;305    	for(i = 0; i < 16; i++)
00007c  4621              MOV      r1,r4
00007e  2000              MOVS     r0,#0
000080  466c              MOV      r4,sp                 ;262
                  |L6.130|
;;;306    	{
;;;307    		u8RxData[i] = 0;
000082  5421              STRB     r1,[r4,r0]
000084  1c40              ADDS     r0,r0,#1
000086  2810              CMP      r0,#0x10              ;305
000088  d3fb              BCC      |L6.130|
;;;308    	}
;;;309    
;;;310    	#if defined (MASTER_I2C_USE_IRQ)	
;;;311    	I2Cx_Read_Multi_FromSlave(addr,reg,u8RxData,len);
00008a  463b              MOV      r3,r7
00008c  4622              MOV      r2,r4
00008e  4629              MOV      r1,r5
000090  4630              MOV      r0,r6
000092  f7fffffe          BL       I2Cx_Read_Multi_FromSlave
;;;312    	#elif defined (MASTER_I2C_USE_POLLING)
;;;313    	I2C_ReadMultiBytesOneReg(MASTER_I2C, addr, reg, u8RxData, 16);
;;;314    	#endif
;;;315    	
;;;316    	printf("\r\nI2Cx_Read  finish\r\n");
000096  a024              ADR      r0,|L6.296|
000098  f7fffffe          BL       __2printf
;;;317    	
;;;318    	for(i = 0; i < 16 ; i++)
00009c  2500              MOVS     r5,#0
;;;319    	{
;;;320    		printf("0x%2X ,", u8RxData[i]);
;;;321       	 	if ((i+1)%8 ==0)
00009e  2601              MOVS     r6,#1
0000a0  0776              LSLS     r6,r6,#29
                  |L6.162|
0000a2  5d61              LDRB     r1,[r4,r5]            ;320
0000a4  a026              ADR      r0,|L6.320|
0000a6  f7fffffe          BL       __2printf
0000aa  0768              LSLS     r0,r5,#29
0000ac  42f0              CMN      r0,r6
0000ae  d102              BNE      |L6.182|
;;;322            {
;;;323                printf("\r\n");
0000b0  a025              ADR      r0,|L6.328|
0000b2  f7fffffe          BL       __2printf
                  |L6.182|
0000b6  1c6d              ADDS     r5,r5,#1
0000b8  2d10              CMP      r5,#0x10              ;318
0000ba  d3f2              BCC      |L6.162|
;;;324            }		
;;;325    	}
;;;326    
;;;327    	printf("\r\n\r\n\r\n");
0000bc  a023              ADR      r0,|L6.332|
0000be  f7fffffe          BL       __2printf
;;;328    
;;;329    	
;;;330    }
0000c2  b009              ADD      sp,sp,#0x24
0000c4  bdf0              POP      {r4-r7,pc}
;;;331    
                          ENDP

0000c6  0000              DCW      0x0000
                  |L6.200|
0000c8  49324378          DCB      "I2Cx_Master_example start\r\n",0
0000cc  5f4d6173
0000d0  7465725f
0000d4  6578616d
0000d8  706c6520
0000dc  73746172
0000e0  740d0a00
                  |L6.228|
0000e4  49324378          DCB      "I2Cx_Write finish\r\n",0
0000e8  5f577269
0000ec  74652066
0000f0  696e6973
0000f4  680d0a00
                  |L6.248|
                          DCD      ||.data||
                  |L6.252|
0000fc  61646472          DCB      "addr : 0x%2X, reg : 0x%2X , data (%2d) : \r\n",0
000100  203a2030
000104  78253258
000108  2c207265
00010c  67203a20
000110  30782532
000114  58202c20
000118  64617461
00011c  20282532
000120  6429203a
000124  200d0a00
                  |L6.296|
000128  0d0a4932          DCB      "\r\nI2Cx_Read  finish\r\n",0
00012c  43785f52
000130  65616420
000134  2066696e
000138  6973680d
00013c  0a00    
00013e  00                DCB      0
00013f  00                DCB      0
                  |L6.320|
000140  30782532          DCB      "0x%2X ,",0
000144  58202c00
                  |L6.328|
000148  0d0a00            DCB      "\r\n",0
00014b  00                DCB      0
                  |L6.332|
00014c  0d0a0d0a          DCB      "\r\n\r\n\r\n",0
000150  0d0a00  
000153  00                DCB      0

                          AREA ||i.I2Cx_Read_Multi_FromSlave||, CODE, READONLY, ALIGN=2

                  I2Cx_Read_Multi_FromSlave PROC
;;;217    
;;;218    void I2Cx_Read_Multi_FromSlave(uint8_t address,uint8_t reg,uint8_t *data,uint16_t len)
000000  b510              PUSH     {r4,lr}
;;;219    { 
;;;220    	g_u8DeviceAddr_m = address;
000002  4c0a              LDR      r4,|L7.44|
000004  7060              STRB     r0,[r4,#1]
;;;221    	rawlenth = len;
000006  70e3              STRB     r3,[r4,#3]
;;;222    	g_au8Reg = reg ;
000008  7121              STRB     r1,[r4,#4]
;;;223    	g_au8Buffer = data;
;;;224    
;;;225    	g_u8EndFlag = 0;
00000a  2000              MOVS     r0,#0
00000c  6122              STR      r2,[r4,#0x10]  ; g_au8Buffer
00000e  7020              STRB     r0,[r4,#0]
;;;226    	g_u8DataLen_m = 0;
000010  70a0              STRB     r0,[r4,#2]
;;;227    
;;;228    	/* I2C function to read data from slave */
;;;229    	I2Cx_Master_HandlerFn = (I2C_FUNC)I2Cx_MasterRx_multi;
000012  4807              LDR      r0,|L7.48|
000014  60a0              STR      r0,[r4,#8]  ; I2Cx_Master_HandlerFn
;;;230    
;;;231    //	printf("I2Cx_MasterRx_multi finish\r\n");
;;;232    	
;;;233    	I2C_SET_CONTROL_REG(MASTER_I2C, I2C_CTL_STA);
000016  4907              LDR      r1,|L7.52|
000018  6808              LDR      r0,[r1,#0]
00001a  223c              MOVS     r2,#0x3c
00001c  4390              BICS     r0,r0,r2
00001e  3020              ADDS     r0,r0,#0x20
000020  6008              STR      r0,[r1,#0]
                  |L7.34|
;;;234    
;;;235    	/* Wait I2C Rx Finish */
;;;236    	while(g_u8EndFlag == 0);
000022  7820              LDRB     r0,[r4,#0]  ; g_u8EndFlag
000024  2800              CMP      r0,#0
000026  d0fc              BEQ      |L7.34|
;;;237    	
;;;238    }
000028  bd10              POP      {r4,pc}
;;;239    
                          ENDP

00002a  0000              DCW      0x0000
                  |L7.44|
                          DCD      ||.data||
                  |L7.48|
                          DCD      I2Cx_MasterRx_multi
                  |L7.52|
                          DCD      0x40080000

                          AREA ||i.I2Cx_Write_Multi_ToSlave||, CODE, READONLY, ALIGN=2

                  I2Cx_Write_Multi_ToSlave PROC
;;;194    
;;;195    void I2Cx_Write_Multi_ToSlave(uint8_t address,uint8_t reg,uint8_t *data,uint16_t len)
000000  b510              PUSH     {r4,lr}
;;;196    {		
;;;197    	g_u8DeviceAddr_m = address;
000002  4c0a              LDR      r4,|L8.44|
000004  7060              STRB     r0,[r4,#1]
;;;198    	rawlenth = len;
000006  70e3              STRB     r3,[r4,#3]
;;;199    	g_au8Reg = reg;
000008  7121              STRB     r1,[r4,#4]
;;;200    	g_au8Buffer = data;
;;;201    
;;;202    	g_u8DataLen_m = 0;
00000a  2100              MOVS     r1,#0
00000c  6122              STR      r2,[r4,#0x10]  ; g_au8Buffer
00000e  70a1              STRB     r1,[r4,#2]
;;;203    	g_u8EndFlag = 0;
000010  7021              STRB     r1,[r4,#0]
;;;204    
;;;205    	/* I2C function to write data to slave */
;;;206    	I2Cx_Master_HandlerFn = (I2C_FUNC)I2Cx_MasterTx_multi;
000012  4807              LDR      r0,|L8.48|
000014  60a0              STR      r0,[r4,#8]  ; I2Cx_Master_HandlerFn
;;;207    
;;;208    //	printf("I2Cx_MasterTx_multi finish\r\n");
;;;209    
;;;210    	/* I2C as master sends START signal */
;;;211    	I2C_SET_CONTROL_REG(MASTER_I2C, I2C_CTL_STA);
000016  4807              LDR      r0,|L8.52|
000018  6802              LDR      r2,[r0,#0]
00001a  233c              MOVS     r3,#0x3c
00001c  439a              BICS     r2,r2,r3
00001e  3220              ADDS     r2,r2,#0x20
000020  6002              STR      r2,[r0,#0]
                  |L8.34|
;;;212    
;;;213    	/* Wait I2C Tx Finish */
;;;214    	while(g_u8EndFlag == 0);
000022  7820              LDRB     r0,[r4,#0]  ; g_u8EndFlag
000024  2800              CMP      r0,#0
000026  d0fc              BEQ      |L8.34|
;;;215    	g_u8EndFlag = 0;
000028  7021              STRB     r1,[r4,#0]
;;;216    }
00002a  bd10              POP      {r4,pc}
;;;217    
                          ENDP

                  |L8.44|
                          DCD      ||.data||
                  |L8.48|
                          DCD      I2Cx_MasterTx_multi
                  |L8.52|
                          DCD      0x40080000

                          AREA ||.data||, DATA, ALIGN=2

                  g_u8EndFlag
000000  00                DCB      0x00
                  g_u8DeviceAddr_m
000001  00                DCB      0x00
                  g_u8DataLen_m
000002  00                DCB      0x00
                  rawlenth
000003  00                DCB      0x00
                  g_au8Reg
000004  00000000          DCB      0x00,0x00,0x00,0x00
                  I2Cx_Master_HandlerFn
                          DCD      0x00000000
                  ||cnt||
                          DCD      0x00000000
                  g_au8Buffer
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\i2c_master.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___12_i2c_master_c_ae965f01____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___12_i2c_master_c_ae965f01____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___12_i2c_master_c_ae965f01____REVSH|
#line 402
|__asm___12_i2c_master_c_ae965f01____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
